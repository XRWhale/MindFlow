<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MindFlow - 보관함</title>
    <link rel="manifest" href="/manifest.json">
    <meta name="theme-color" content="#667eea">
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #667eea, #764ba2);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            color: #fff;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1.5rem 1rem 6rem;
        }

        /* Top bar */
        .top-bar {
            width: 100%; max-width: 480px;
            display: flex; align-items: center; justify-content: space-between;
            margin-bottom: 1.5rem;
        }
        .top-bar h1 { font-size: 1.5rem; font-weight: 700; }
        .top-bar .count { font-size: 0.85rem; opacity: 0.6; }
        .back-link {
            color: #fff; text-decoration: none; font-size: 0.9rem; opacity: 0.7;
        }
        .back-link:hover { opacity: 1; }

        /* Card list */
        #cardList { width: 100%; max-width: 480px; }

        .card {
            background: rgba(255,255,255,0.12);
            backdrop-filter: blur(12px);
            border-radius: 16px;
            padding: 0;
            overflow: hidden;
            width: 100%;
            margin-bottom: 0.75rem;
            border: 1px solid rgba(255,255,255,0.15);
            animation: slideUp 0.3s ease-out;
        }
        .card-hero-image {
            width: 100%; max-height: 300px; object-fit: cover;
            display: block; cursor: pointer;
        }
        .card-body {
            padding: 1rem 1.1rem;
        }
        .card-header {
            display: flex; justify-content: space-between; align-items: flex-start;
        }
        .card-title {
            font-size: 1rem; font-weight: 600;
            flex: 1; padding-right: 0.5rem;
            line-height: 1.4;
        }
        .card-text {
            word-break: break-word; line-height: 1.5; font-size: 0.88rem;
            opacity: 0.85; margin-top: 0.4rem;
            display: -webkit-box; -webkit-line-clamp: 3;
            -webkit-box-orient: vertical; overflow: hidden;
        }
        .card-url { margin-top: 0.4rem; }
        .card-url a {
            color: #ffd700; text-decoration: none; font-size: 0.82rem;
            word-break: break-all;
        }
        .card-url a:hover { text-decoration: underline; }

        /* Skeleton */
        .skeleton {
            background: linear-gradient(90deg, rgba(255,255,255,0.08) 25%, rgba(255,255,255,0.15) 50%, rgba(255,255,255,0.08) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
            border-radius: 0;
        }
        .skeleton-hero { width: 100%; height: 200px; }
        .skeleton-text { height: 14px; width: 70%; margin-top: 0.5rem; border-radius: 8px; }
        @keyframes shimmer { to { background-position: -200% 0; } }

        /* Meta row */
        .card-meta {
            display: flex; justify-content: space-between; align-items: center;
            margin-top: 0.6rem; padding-top: 0.5rem;
            border-top: 1px solid rgba(255,255,255,0.08);
        }
        .card-time { font-size: 0.78rem; opacity: 0.45; }
        .card-source {
            font-size: 0.72rem; opacity: 0.5;
            background: rgba(255,255,255,0.1); padding: 0.15rem 0.5rem;
            border-radius: 20px;
        }
        .delete-btn {
            background: none; border: none; color: rgba(255,255,255,0.4);
            font-size: 1.1rem; cursor: pointer; padding: 0.2rem 0.4rem;
            border-radius: 8px; transition: all 0.15s;
        }
        .delete-btn:hover { background: rgba(255,255,255,0.1); color: #ff6b6b; }
        .delete-btn:active { transform: scale(0.9); }

        /* URL input */
        .add-bar {
            width: 100%; max-width: 480px;
            display: flex; gap: 0.5rem;
            margin-bottom: 1rem;
        }
        .add-bar input {
            flex: 1; padding: 0.7rem 1rem;
            border-radius: 12px; border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.1); color: #fff;
            font-size: 0.9rem; outline: none;
        }
        .add-bar input::placeholder { color: rgba(255,255,255,0.4); }
        .add-bar input:focus { border-color: rgba(255,255,255,0.5); background: rgba(255,255,255,0.15); }
        .add-bar button {
            padding: 0.7rem 1rem; border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.3);
            background: rgba(255,255,255,0.2); color: #fff;
            font-size: 0.9rem; font-weight: 600; cursor: pointer;
            white-space: nowrap; transition: background 0.15s;
        }
        .add-bar button:hover { background: rgba(255,255,255,0.3); }
        .add-bar button:active { transform: scale(0.97); }

        .empty-state { text-align: center; padding: 3rem 1rem; opacity: 0.7; }
        .empty-state .icon { font-size: 3rem; margin-bottom: 1rem; }
        .hidden { display: none; }

        /* Bottom nav */
        .bottom-nav {
            position: fixed; bottom: 0; left: 0; right: 0;
            background: rgba(30,20,60,0.85); backdrop-filter: blur(12px);
            display: flex; justify-content: center; gap: 2rem;
            padding: 0.75rem 1rem; padding-bottom: max(0.75rem, env(safe-area-inset-bottom));
            border-top: 1px solid rgba(255,255,255,0.1);
        }
        .bottom-nav a {
            color: #fff; text-decoration: none; font-size: 0.82rem;
            opacity: 0.6; text-align: center; display: flex;
            flex-direction: column; align-items: center; gap: 0.2rem;
        }
        .bottom-nav a.active { opacity: 1; }
        .bottom-nav a .icon { font-size: 1.3rem; }

        @keyframes slideUp {
            from { opacity: 0; transform: translateY(16px); }
            to { opacity: 1; transform: translateY(0); }
        }
    </style>
</head>
<body>
    <div class="top-bar">
        <div>
            <h1>&#128451; 보관함</h1>
            <div class="count" id="itemCount"></div>
        </div>
    </div>

    <div class="add-bar">
        <input type="url" id="urlInput" placeholder="URL을 붙여넣기..." autocomplete="off">
        <button id="addBtn">추가</button>
    </div>

    <div id="cardList">
        <div class="empty-state" id="emptyState">
            <div class="icon">&#128233;</div>
            <p>아직 공유된 콘텐츠가 없습니다.<br>다른 앱에서 공유하기를 눌러보세요!</p>
        </div>
    </div>

    <nav class="bottom-nav">
        <a href="/"><span class="icon">&#127968;</span>홈</a>
        <a href="/home" class="active"><span class="icon">&#128451;</span>보관함</a>
        <a href="/report"><span class="icon">&#129302;</span>리포트</a>
    </nav>

    <script type="module">
        import { getItems, addItem, deleteItem, updateItem, timeAgo, escapeHtml } from '/js/storage.js';
        import { resolveAndUpdate } from '/js/resolve.js';

        const list = document.getElementById('cardList');
        const empty = document.getElementById('emptyState');
        const countEl = document.getElementById('itemCount');
        const urlInput = document.getElementById('urlInput');
        const addBtn = document.getElementById('addBtn');

        // Manual URL add
        function handleAdd() {
            const raw = urlInput.value.trim();
            if (!raw) return;
            try { new URL(raw); } catch { urlInput.value = ''; return; }
            addItem('', '', raw);
            urlInput.value = '';
            render();
        }
        addBtn.addEventListener('click', handleAdd);
        urlInput.addEventListener('keydown', (e) => { if (e.key === 'Enter') handleAdd(); });

        function render() {
            list.querySelectorAll('.card').forEach((c) => c.remove());
            const items = getItems();

            if (items.length === 0) {
                empty.classList.remove('hidden');
                countEl.textContent = '';
                return;
            }
            empty.classList.add('hidden');
            countEl.textContent = `총 ${items.length}개`;

            for (const item of items) {
                list.appendChild(buildCard(item));
            }
        }

        function buildCard(item) {
            const card = document.createElement('div');
            card.className = 'card';
            card.dataset.id = item.id;

            const displayTitle = item.ogTitle || item.title || '';
            const displayText = item.ogDescription || item.text || '';
            const needsResolve = item.url && !item.resolved;
            // Re-resolve Instagram items that were resolved before oEmbed was added
            const needsReResolve = item.resolved && item.resolveV !== 5
                && item.url && item.url.includes('instagram.com');

            let html = '';

            // Hero image at top of card
            if (item.ogImage) {
                html += `<a href="${escapeHtml(item.url)}" target="_blank"><img class="card-hero-image" src="${escapeHtml(item.ogImage)}" alt="" loading="lazy" onerror="this.style.display='none'"></a>`;
            } else if (needsResolve || needsReResolve) {
                html += `<div class="skeleton skeleton-hero" data-slot="image"></div>`;
            }

            // Card body with text content
            html += '<div class="card-body">';
            html += '<div class="card-header">';
            html += `<div class="card-title">${escapeHtml(displayTitle) || '<span style="opacity:0.5">(제목 없음)</span>'}</div>`;
            html += `<button class="delete-btn" data-id="${item.id}" title="삭제">&#128465;</button>`;
            html += '</div>';

            if (displayText) {
                html += `<div class="card-text">${escapeHtml(displayText)}</div>`;
            } else if (needsResolve || needsReResolve) {
                html += `<div class="skeleton skeleton-text" data-slot="text"></div>`;
            }

            if (item.url) {
                html += `<div class="card-url"><a href="${escapeHtml(item.url)}" target="_blank">${escapeHtml(item.url)}</a></div>`;
            }

            html += '<div class="card-meta">';
            html += `<span class="card-time">${timeAgo(item.createdAt)}</span>`;
            if (item.ogSource) {
                html += `<span class="card-source">${escapeHtml(item.ogSource)}</span>`;
            }
            html += '</div>';
            html += '</div>'; // card-body

            card.innerHTML = html;

            // Resolve metadata if needed (new or re-resolve for Instagram)
            if (needsResolve || needsReResolve) {
                resolveAndUpdate(item.id, item.url).then((meta) => {
                    if (!meta) {
                        card.querySelectorAll('.skeleton').forEach((s) => s.remove());
                        return;
                    }
                    // Update title
                    const titleEl = card.querySelector('.card-title');
                    if (meta.title && titleEl) titleEl.textContent = meta.title;

                    // Update description
                    const textSlot = card.querySelector('[data-slot="text"]');
                    const textEl = card.querySelector('.card-text');
                    if (meta.description) {
                        if (textSlot) {
                            textSlot.classList.remove('skeleton', 'skeleton-text');
                            textSlot.className = 'card-text';
                            textSlot.textContent = meta.description;
                        } else if (textEl) {
                            textEl.textContent = meta.description;
                        } else {
                            const div = document.createElement('div');
                            div.className = 'card-text';
                            div.textContent = meta.description;
                            card.querySelector('.card-url')?.before(div);
                        }
                    } else if (textSlot) {
                        textSlot.remove();
                    }

                    // Replace hero skeleton with image
                    const heroSlot = card.querySelector('[data-slot="image"]');
                    if (heroSlot) heroSlot.remove();
                    if (meta.image) {
                        const link = document.createElement('a');
                        link.href = item.url;
                        link.target = '_blank';
                        const img = document.createElement('img');
                        img.className = 'card-hero-image';
                        img.src = meta.image;
                        img.loading = 'lazy';
                        img.onerror = () => link.style.display = 'none';
                        link.appendChild(img);
                        card.insertBefore(link, card.firstChild);
                    }

                    // Source badge
                    if (meta.source) {
                        const existing = card.querySelector('.card-source');
                        if (existing) { existing.textContent = meta.source; }
                        else {
                            const badge = document.createElement('span');
                            badge.className = 'card-source';
                            badge.textContent = meta.source;
                            card.querySelector('.card-meta')?.appendChild(badge);
                        }
                    }
                });
            }

            return card;
        }

        // Delete (event delegation)
        list.addEventListener('click', (e) => {
            const btn = e.target.closest('.delete-btn');
            if (!btn) return;
            const id = btn.dataset.id;
            if (id) { deleteItem(id); render(); }
        });

        // Update times every minute
        setInterval(() => {
            const items = getItems();
            document.querySelectorAll('.card').forEach((card) => {
                const id = card.dataset.id;
                const item = items.find((i) => i.id === id);
                const timeEl = card.querySelector('.card-time');
                if (item && timeEl) timeEl.textContent = timeAgo(item.createdAt);
            });
        }, 60000);

        render();
    </script>
</body>
</html>
